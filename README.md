# Fake Microservice

A NestJS microservice that simulates supplier performance analysis and automated decision-making processes, mimicking the behavior of an AI assistant named Connie. The service uses BullMQ and Redis to handle background tasks for data generation and supplier evaluation. It periodically updates a PostgreSQL database with supplier performance metrics, evaluates existing suppliers by comparing them to each other, and generates recommendations and actions for human intervention.

## Table of Contents

- [Features](#features)
- [Architecture](#architecture)
- [Technologies Used](#technologies-used)
- [Prerequisites](#prerequisites)
- [Getting Started](#getting-started)
  - [Clone the Repository](#clone-the-repository)
  - [Environment Variables](#environment-variables)
  - [Build and Run with Docker Compose](#build-and-run-with-docker-compose)
- [Usage](#usage)
- [Testing](#testing)
- [Future Enhancements](#future-enhancements)
- [License](#license)

---

## Features

- **Background Task Processing**: Utilizes BullMQ and Redis for managing background jobs for data generation and supplier evaluation.
- **Periodic Data Generation**: Generates fake supplier performance metrics at scheduled intervals using BullMQ repeatable jobs.
- **Supplier Evaluation**: Compares existing suppliers to identify underperforming suppliers based on various performance metrics.
- **Automated Recommendations**: Recommends actions such as contacting better-performing suppliers and considering termination of underperforming suppliers.
- **Action Generation**: Creates actionable items and simulates email drafts for human review.
- **Database Interaction**: Interacts with a PostgreSQL database using TypeORM for object-relational mapping.
- **Unit Testing**: Includes unit tests for business logic to ensure code quality and reliability.

## Architecture

The microservice follows a modular architecture using NestJS, with the following key components:

- **Entities**: Define the database schema using TypeORM entities for suppliers, performance metrics, recommendations, actions, and emails.
- **Services**:
  - **SupplierService**: Manages supplier data.
  - **PerformanceMetricService**: Handles performance metrics data.
  - **RecommendationService**: Manages supplier recommendations.
  - **ActionService**: Handles actions generated by Connie.
  - **EmailService**: Simulates email sending functionality.
- **Processors**:
  - **DataGeneratorProcessor**: Processes data generation jobs.
  - **SupplierComparisonProcessor**: Processes supplier comparison jobs.
- **BullMQ Queues**: Uses BullMQ queues for managing background jobs with Redis as the backend.
- **Database**: PostgreSQL database managed via Docker Compose, initialized with SQL scripts.

## Technologies Used

- **Node.js**: JavaScript runtime environment.
- **NestJS**: Framework for building scalable server-side applications.
- **TypeScript**: Typed superset of JavaScript.
- **TypeORM**: ORM for TypeScript and JavaScript.
- **PostgreSQL**: Relational database system.
- **Redis**: In-memory data structure store used as a message broker for BullMQ.
- **BullMQ**: A Node.js library for handling jobs and messages in Node.js applications.
- **Docker**: Containerization platform.
- **Docker Compose**: Tool for defining and running multi-container Docker applications.
- **Jest**: Testing framework for unit tests.
- **Bull Board**: Optional UI for monitoring BullMQ queues (not included by default).

## Prerequisites

- **Docker**: Ensure Docker and Docker Compose are installed on your system.
- **Node.js and NPM**: For local development and testing (optional).
- **Redis**: Included in the Docker Compose setup; no additional installation required.

## Getting Started

### Clone the Repository

```bash
git clone https://github.com/yourusername/fake-microservice.git
cd fake-microservice
```

### Environment Variables

Create a `.env` file in the project root to configure environment variables:

```bash
# .env file example

# -------------------------------------
# Database Configuration
# -------------------------------------

DB_HOST=db
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=yourpassword
DB_NAME=supplier_db

# -------------------------------------
# Redis Configuration
# -------------------------------------

REDIS_HOST=redis
REDIS_PORT=6379

# -------------------------------------
# Email Configuration (Optional)
# -------------------------------------

EMAIL_HOST=smtp.example.com
EMAIL_PORT=587
EMAIL_SECURE=false
EMAIL_USER=your_email@example.com
EMAIL_PASSWORD=your_email_password
EMAIL_FROM="Connie <connie@example.com>"
```

**Note**:

- Replace `yourpassword` with a secure password for the PostgreSQL database.
- Update the email configuration if you plan to test email functionality. Otherwise, you can leave the email settings as placeholders.

### Build and Run with Docker Compose

Build and start the application using Docker Compose:

```bash
docker-compose up --build
```

This command will:

- Build the Docker image for the NestJS application.
- Start the PostgreSQL database container.
- Start the Redis container.
- Initialize the database with the provided SQL scripts.
- Start the NestJS application after the database and Redis are ready.

**Accessing the Application**:

- The microservice runs without exposing HTTP endpoints by default.
- A health check endpoint is available at `http://localhost:3000/health`.

## Usage

- **Background Jobs**: The service generates data and evaluates suppliers using BullMQ queues. Jobs are scheduled to run at intervals defined in the processors.

- **Monitoring Jobs**:

  - **Logs**: Monitor the application logs to see the output of background jobs:

    ```bash
    docker-compose logs -f app
    ```

  - **BullMQ UI (Optional)**: You can integrate a UI like [Bull Board](https://github.com/felixmosh/bull-board) to monitor queues and jobs.

- **Database Access**: Connect to the PostgreSQL database to inspect data:

  ```bash
  docker exec -it fake-microservice-db-1 psql -U postgres -d supplier_db
  ```

  Example SQL queries:

  ```sql
  SELECT * FROM suppliers;
  SELECT * FROM supplier_performance_metrics;
  SELECT * FROM suppliers_to_evaluate;
  SELECT * FROM actions_generated_by_connie;
  SELECT * FROM emails;
  ```

## Testing

- **Unit Tests**: The project includes unit tests for business logic, particularly in the `SupplierComparisonProcessor`.

  - **Run Tests**:

    ```bash
    npm run test
    ```

  - **Test Watch Mode**:

    ```bash
    npm run test:watch
    ```

  - **Test Coverage**:

    ```bash
    npm run test:cov
    ```

- **Adjust Job Scheduling for Testing**:

  - The job intervals are defined using BullMQ's repeatable jobs. For testing purposes, you can adjust the repeat intervals in the service files.

  - **Example**:

    ```typescript
    // In data-generator.service.ts and supplier-comparison.service.ts

    await this.queue.add(
      'job-name',
      {},
      { repeat: { every: 60 * 1000 } } // Runs every 1 minute
    );
    ```

## Future Enhancements

- **Improve Comparison Logic**: Enhance supplier evaluation algorithms to consider additional metrics and weights.
- **User Interface**: Develop a frontend to display recommendations and actions for human users.
- **API Endpoints**: Expose RESTful APIs for external interaction.
- **Authentication and Security**: Implement security measures for any exposed endpoints.
- **Configuration Management**: Use Docker secrets or a configuration service for managing sensitive information.
- **Error Handling and Logging**: Enhance error handling and integrate advanced logging mechanisms.
- **Monitoring Tools**: Integrate tools like Bull Board for monitoring BullMQ queues.

## License

This project is licensed under the MIT License.

---

**Note**: This project is a simulation and does not interact with real suppliers or send actual emails. It is intended for educational and testing purposes.

---

If you have any questions or need assistance, please feel free to contact the project maintainer.
